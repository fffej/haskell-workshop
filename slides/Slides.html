<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Jeff Foster" />
  <title>Haskell Workshop</title>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Haskell Workshop</h1>
  <p class="author">
Jeff Foster
  </p>
  <p class="date">Cambridge Software Craftsmanship</p>
</div>
<div class="section slide level1" id="about-me">
<h1>About me!</h1>
<ul>
<li>I'm head of software engineering at Red Gate</li>
<li>I'm most definitely NOT a Haskell expert</li>
<li>Love learning new languages, tools and techniques</li>
</ul>
</div>
<div class="section slide level1" id="why-haskell">
<h1>Why Haskell?</h1>
<ul>
<li>Purely functional, statically typed, lazy</li>
<li>Different is good!</li>
</ul>
</div>
<div class="section slide level1" id="what-are-you-going-to-do-today">
<h1>What are you going to do today?</h1>
<ul class="incremental">
<li>You'll the basics of Haskell</li>
<li>You'll learn to read Haskell</li>
<li>You'll write a combinator library for analysing Premier League football matches</li>
</ul>
</div>
<div class="section slide level1" id="hello-world">
<h1>Hello, World!</h1>
<pre><code>   module Main where

   main = putStrLn &quot;Hello, World!&quot;</code></pre>
<ul>
<li>Every Haskell program needs a &quot;Main&quot; module</li>
<li><code>main</code> is the entry point</li>
<li>Run with <code>runghc HelloWorld.hs</code> or compile with <code>ghc</code></li>
</ul>
<!-- Quick stop to let everyone find out that Haskell works for them -->

</div>
<div class="section slide level1" id="ghci">
<h1>GHCI</h1>
<ul>
<li>GHCI is the de-facto Haskell interpreter</li>
<li>Provides a REPL and a way to explore the code</li>
<li>Expressions entered are evaluated and returned, for example:</li>
</ul>
<pre><code>  &gt; 1 -- Int, Integer, Double, Char, Float
  =&gt; 1

  &gt; 1 + 1 -- standard arithmetic operators (*, /, +, -, ==, /=)
  =&gt; 2

  &gt; &quot;hello&quot; -- strings are lists of characters
  =&gt; &quot;hello&quot;

  &gt; [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;] -- lists are homogenous collections
  =&gt; &quot;hello&quot;

  &gt; (&quot;Banana&quot;, 345) -- tuples provide hetereogenous collections
  =&gt; (&quot;Banana&quot;, 345)</code></pre>
</div>
<div class="section slide level1" id="lets-write-some-functions-and-explore-some-syntax">
<h1>Let's write some functions and explore some syntax</h1>
<pre><code>  add x y = x + y

  -- Guards
  add2 x y 
    | x == 0 = y
    | y == 0 = x
    | otherwise = 1 + add2 (x - 1) y

  -- Pattern matching
  add3 0 y = y
  add3 x 0 = x
  add3 x y = 1 + add3 (x - 1) y</code></pre>
<ul class="incremental">
<li>Can you write factorial and fibonacci functions?</li>
</ul>
</div>
<div class="section slide level1" id="types">
<h1>Types</h1>
<ul>
<li>We haven't written type signatures yet</li>
<li>Haskell has inferred types for us</li>
<li>In ghci, <code>:t &lt;expression&gt;</code> tells us the type</li>
<li><code>:t (+)</code> says <code>(+) :: Num a =&gt; a -&gt; a -&gt; a</code></li>
<li>What does this mean?</li>
</ul>
</div>
<div class="section slide level1" id="types-are-everything">
<h1>Types are everything</h1>
<ul>
<li>Often a type signature says everything about a function.</li>
<li>What do these functions do? (hint, remember they must work for all types)</li>
<li>fooHicky :: (a,b) -&gt; a</li>
<li>banana :: a -&gt; a</li>
</ul>
</div>
<div class="section slide level1" id="type-classes">
<h1>Type Classes</h1>
<ul>
<li>Think of a type class as an interface</li>
<li>Common type classes are <code>Eq</code> and <code>Show</code> which define equality and printability</li>
<li>Use <code>:i &lt;TypeClass&gt;</code> to inspect a type class in ghci e.g.</li>
</ul>
<pre><code>  &gt; :i Num
  class Num a where
    (+) :: a -&gt; a -&gt; a
    (*) :: a -&gt; a -&gt; a
    --etc</code></pre>
<ul>
<li>You can automatically derive <code>Show</code> and <code>Eq</code> to get printable and equality support</li>
</ul>
</div>
<div class="section slide level1" id="defining-new-types">
<h1>Defining new types</h1>
<ul>
<li>Data types are constructed via type constructors</li>
<li>Data types are pattern matched via type constructors</li>
</ul>
<pre><code>  -- Point is the type
  -- PointC is the type constructor
  data Point = PointC Int Int deriving (Show,Eq)

  -- Use the type constructor to take things apart
  isOrigin :: Point -&gt; Bool
  isOrigin (PointC 0 0) = True
  isOrigin _            = False

  -- Use the type constructor to take things apart
  manhattanDistance :: Point -&gt; Int
  manhattanDistance (PointC x y) = x + y</code></pre>
</div>
<div class="section slide level1" id="sum-types">
<h1>Sum Types</h1>
<ul>
<li>A sum type can be one of many possibilities</li>
</ul>
<pre><code>  data Shape = Square Double
             | Circle Double 
             | Rectangle Double Double
             deriving (Show, Eq)</code></pre>
<ul class="incremental">
<li>How would you write a function <code>area :: Shape -&gt; Double</code>?</li>
<li>Remember, use the type constructor to take things apart!</li>
</ul>
</div>
<div class="section slide level1" id="recursive-types">
<h1>Recursive Types</h1>
<ul>
<li>A data type can also refer to itself (e.g. a List or a Tree)</li>
</ul>
<pre><code>   -- imagine Haskell didn&#39;t have lists, how would you write it?

   data List a = Cons a (List a)
               | Empty

  
   list123 = Cons 1 (Cons 2 (Cons 3 Empty))
   
   myLength :: List a -&gt; Int
   myLength Empty = 0
   myLength (Cons x xs) = 1 + myLength xs 

   myLength list123
   &gt; 1 + myLength (Cons 2 (Cons 3 Empty))
   &gt; 1 + 1 + myLength (Cons 3 Empty)
   &gt; 1 + 1 + 1 + myLength Empty
   &gt; 1 + 1 + 1 + 0
   =&gt; 3</code></pre>
</div>
<div class="section slide level1" id="record-syntax">
<h1>Record syntax</h1>
<ul>
<li>Allows you to generate names for parts of a type</li>
</ul>
<pre><code>
   data Person = PersonC
      {
        firstName :: String,
        lastName  :: String
      }

   -- Automatically generates accessor methods
   -- lastName :: Person -&gt; String
   -- firstName :: Person -&gt; String
   aPerson = PersonC { firstName = &quot;Joe&quot;, lastName = &quot;Bloggs&quot; }

   &gt; lastName aPerson
   =&gt; &quot;Bloggs&quot; </code></pre>
</div>
<div class="section slide level1" id="enough-talking">
<h1>Enough Talking</h1>
<ul>
<li>Write some data types for a Premier League football match
<ul>
<li>e.g. Everton 1 - Man United 0 (first team is the home team)</li>
</ul></li>
<li>Write some simple functions to give information such as:
<ul>
<li>homeWin :: Game -&gt; Bool</li>
<li>awayWin :: Game -&gt; Bool</li>
<li>scoreDraw :: Game -&gt; Bool</li>
<li>totalGoals :: Game -&gt; Int</li>
</ul></li>
</ul>
</div>
<div class="section slide level1" id="lists-in-a-bit-more-detail">
<h1>Lists in a bit more detail</h1>
<ul>
<li>All items in a list have to be the same type (no <code>[1,&quot;a&quot;]</code>)</li>
<li>Lists have special syntax in Haskell</li>
<li><code>[]</code> is the empty list</li>
<li><code>:</code> is the type constructor used to create lists <code>1 : [] =&gt; [1]</code></li>
<li><code>[1,2,3]</code> is syntactic sugar for <code>1 : (2 : (3 : []) )</code></li>
</ul>
</div>
<div class="section slide level1" id="lets-write-some-list-functions">
<h1>Let's write some list functions</h1>
<ul>
<li>Need to think recursively!</li>
<li>What's the base case?</li>
<li>What's the recursive case?</li>
</ul>
</div>
<div class="section slide level1" id="length">
<h1>Length</h1>
<pre><code>   -- base case, an empty list
   length [] = 0

   -- recursive case is a list of at least one element
   length (_:xs) = 1 + length xs</code></pre>
</div>
<div class="section slide level1" id="adding-one-to-each-element">
<h1>Adding one to each element</h1>
<pre><code>   addOne :: [Int] -&gt; [Int]
   addOne [] = []
   addOne (x:xs) = (x + 1) : (addOne xs)</code></pre>
</div>
<div class="section slide level1" id="higher-order-functions">
<h1>Higher Order Functions</h1>
<ul>
<li>As you might expect functions are first class citizens</li>
<li>You can pass them to methods, partially apply them</li>
</ul>
<pre><code>   map :: (a -&gt; b) -&gt; [a] -&gt; [b]
   map f []     = []
   map f (x:xs) = f x : map xs 

   -- more succinct definition
   -- point free (no args), partial application (+ 1)
   addOne = map (+ 1)</code></pre>
</div>
<div class="section slide level1" id="writing-list-functions">
<h1>Writing List functions</h1>
<ul>
<li>Can you write the following functions?
<ul>
<li><code>myContains :: Eq a =&gt; a -&gt; [a] -&gt; Bool</code></li>
<li><code>myFilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></li>
<li><code>myAppend :: [a] -&gt; [a] -&gt; [a]</code></li>
<li><code>myReduce :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</code></li>
<li><code>myReverse :: [a] -&gt; [a]</code></li>
</ul></li>
</ul>
</div>
<div class="section slide level1" id="making-the-most-of-higher-order-functions">
<h1>Making the most of higher order functions</h1>
<ul>
<li>Function composition f . g =&gt; f g (x)</li>
</ul>
<pre><code>    sort :: Ord a =&gt; [a] -&gt; [a]
    reverse :: [a] -&gt; [a]

    -- writing a definition
    reverseSort xs = reverse (sort xs)

    -- using function composition
    reverseSort = reverse . sort
</code></pre>
</div>
<div class="section slide level1" id="returning-functions-with-partial-application">
<h1>Returning functions with partial application</h1>
<pre><code>
  moreThanNGoals :: Int -&gt; Match -&gt; Bool
  moreThanNGoals n match = totalGoals match &gt; n

  excitingGame :: Match -&gt; Bool
  excitingGame = moreThanNGoals 10</code></pre>
</div>
<div class="section slide level1" id="putting-it-all-together">
<h1>Putting it all together</h1>
<ul>
<li>We're going to work with Premier League Data for this season</li>
<li>We're going to write some code to allow us to quiz the data</li>
<li>From the REPL, I want to be able to ask questions like:
<ul>
<li>What game had the most goals?</li>
<li>What was the total number of goals scored?</li>
<li>Which team got most corners?</li>
<li>Which team was most entertaining?</li>
<li>If all games finished at half-time, who'd have won the league?</li>
</ul></li>
</ul>
</div>
<div class="section slide level1" id="property-based-testing">
<h1>Property Based Testing</h1>
<ul>
<li>The type system can encode lots of properties about your data</li>
<li>Property based tested can help you assert more about your data</li>
<li>Instead of existential tests (<code>assert 1 + 1 == 2</code>) write universal tests (<code>a + b == b + a</code>)</li>
</ul>
</div>
<div class="section slide level1" id="asserting-invariants">
<h1>Asserting Invariants</h1>
<pre><code>  reverse :: [a] -&gt; [a]
  
  prop_LenPreserving :: [a] -&gt; Bool
  prop_LenPreserving xs = length xs == length (reverse xs)

  &gt; quickCheck prop_LenPreserving
  +++ OK, passed 100 tests
</code></pre>
</div>
<div class="section slide level1" id="finding-errors">
<h1>Finding errors</h1>
<pre><code>  badSort :: Ord a =&gt; [a] -&gt; [a]
  badSort [] = []
  badSort xs = minimum xs : tail xs

  &gt; badSort [1,2,3,4] 
  [1,2,3,4]

  model_test :: [Int] -&gt; Bool
  model_test xs = sort xs == badSort xs

  &gt; quickCheck model_test
  *** Failed! Falsifiable (after 4 tests):
  [0, -1]</code></pre>
</div>
</body>
</html>
