<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Jeff Foster" />
  <title>Haskell Workshop</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Haskell Workshop</h1>
  <p class="author">
Jeff Foster
  </p>
  <p class="date">ACCU 2014</p>
</div>
<div id="about-me" class="slide section level1">
<h1>About me!</h1>
<ul>
<li>I'm Head of Software Engineering at Red Gate</li>
<li>I'm most definitely NOT a Haskell expert</li>
<li>Love learning new languages, tools and techniques</li>
</ul>
</div>
<div id="why-haskell" class="slide section level1">
<h1>Why Haskell?</h1>
<ul>
<li>Purely functional, statically typed, lazy</li>
<li>Different is good!</li>
</ul>
<blockquote>
<p>A language that doesn't affect the way you think about programming is not worth knowing. (Alan Perlis)</p>
</blockquote>
</div>
<div id="what-do-you-need-today" class="slide section level1">
<h1>What do you need today?</h1>
<ul>
<li>A text editor</li>
<li>A version of the Haskell Platform <a href="http://www.haskell.org/platform/">http://www.haskell.org/platform/</a></li>
<li>A git clone of <a href="https://github.com/fffej/haskell-workshop">https://github.com/fffej/haskell-workshop</a></li>
</ul>
</div>
<div id="what-are-you-going-to-do-today" class="slide section level1">
<h1>What are you going to do today?</h1>
<ul class="incremental">
<li>You'll the basics of Haskell</li>
<li>You'll learn to read Haskell</li>
<li>You'll write a combinator library for analysing Premier League football matches</li>
</ul>
</div>
<div id="why-statically-typed" class="slide section level1">
<h1>Why Statically Typed?</h1>
<ul class="incremental">
<li>Given the type signature below, what happens?</li>
</ul>
<div class="incremental">
<pre><code>   int add(int x,int y);</code></pre>
<ul class="incremental">
<li>Add two integers? Maybe... Or maybe</li>
</ul>
</div>
<div class="incremental">
<pre><code>   int add(int x,int y) { launchNukes(); return x+y; };</code></pre>
</div>
</div>
<div id="haskell-types" class="slide section level1">
<h1>Haskell types</h1>
<ul class="incremental">
<li>Given the type signature below, what happens?</li>
</ul>
<div class="incremental">
<pre><code>   add :: Int -&gt; Int -&gt; Int</code></pre>
<ul class="incremental">
<li>What can happen?</li>
</ul>
</div>
</div>
<div id="lets-check-everything-is-working." class="slide section level1">
<h1>Let's check everything is working.</h1>
<ul>
<li>Put the following in <code>Main.hs</code></li>
</ul>
<pre><code>   module HelloWorld where
   main = putStrLn &quot;Hello, World!&quot;</code></pre>
<ul>
<li>Each Haskell function is within a module</li>
<li><code>main</code> is the entry point</li>
<li>Load this into ghci with <code>:l Main.hs</code> and run with <code>main</code></li>
</ul>
<!-- 
     Quick stop to let everyone find out that Haskell works for them 
     5 minutes?  Hopefully enough people have working machines
-->

</div>
<div id="ghci" class="slide section level1">
<h1>GHCI</h1>
<ul>
<li>GHCI is the de-facto Haskell interpreter</li>
<li>Provides a REPL and a way to explore the code</li>
<li>Expressions entered are evaluated and returned</li>
<li>For this workshop, work in a file and use <code>:l &lt;file&gt;</code> to reload</li>
</ul>
</div>
<div id="lets-write-some-simple-functions-and-explore-some-syntax" class="slide section level1">
<h1>Let's write some simple functions and explore some syntax</h1>
<pre><code>
  module Add where

  -- function definition
  add x y = x + y

  -- Pattern matching
  add2 0 y = y
  add2 x 0 = x
  add2 x y = 1 + add2 (x - 1) y

  -- Guards 
  add3 x y 
    | x == 0    = y -- read | as &quot;where&quot;
    | y == 0    = x
    | otherwise = 1 + add3 (x - 1) y
</code></pre>
</div>
<div id="types" class="slide section level1">
<h1>Types</h1>
<ul>
<li>We haven't written type signatures yet</li>
<li>Haskell has inferred types for us</li>
<li>In ghci, <code>:t &lt;expression&gt;</code> tells us the type</li>
<li><code>:t add</code> says <code>add :: Num a =&gt; a -&gt; a -&gt; a</code></li>
</ul>
</div>
<div id="types-are-everything" class="slide section level1">
<h1>Types are everything</h1>
<ul>
<li>Often a type signature says <em>everything</em> about a function.</li>
<li>Types are denoted with an initial Capital letter</li>
<li>Type parameters (generics) are written with a lower case parameter</li>
<li>What do these functions do? (hint, remember they must work for all types)</li>
<li><code>fooHicky :: (a,b) -&gt; a</code></li>
<li><code>banana   :: a -&gt; a</code></li>
</ul>
</div>
<div id="types-or-type-variables" class="slide section level1">
<h1>Types or type variables?</h1>
<ul>
<li>What does the type <code>Int -&gt; Int -&gt; Int</code> tell you?</li>
<li>What does the type <code>a -&gt; a -&gt; a</code> tell you?</li>
<li>The more general the type signature, the <em>more</em> it tells you!</li>
</ul>
<!-- I think I can skip the section on Type classes? -->

</div>
<div id="type-classes" class="slide section level1">
<h1>Type Classes</h1>
<ul>
<li>Think of a type class as an interface</li>
<li>Common type classes are <code>Eq</code> and <code>Show</code> which define equality and printability</li>
<li>Use <code>:i &lt;TypeClass&gt;</code> to inspect a type class in ghci e.g.</li>
</ul>
<pre><code>  &gt; :i Eq
  class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
    --etc</code></pre>
</div>
<div id="building-your-own-types" class="slide section level1">
<h1>Building your own types</h1>
<ul>
<li>Data types are constructed via <em>type constructors</em></li>
<li>Data types are pattern matched via <em>type constructors</em></li>
</ul>
<pre><code>    module SimpleTypes where

    -- Game is the type
    -- GameC is the type constructor
    data Game = GameC String Int String Int

    -- Function type signatures use the type
    result :: Game -&gt; String

    -- Function definitions &quot;Deconstruct&quot; values with the type constructor
    result (GameC t1 s1 t2 s2)
      | s1 &gt; s2   = t1 ++ &quot; wins&quot;
      | s2 &gt; s1   = t2 ++ &quot; wins&quot;
      | otherwise = &quot;Draw&quot;</code></pre>
</div>
<div id="record-syntax" class="slide section level1">
<h1>Record Syntax</h1>
<ul>
<li>Provides a way of naming parts of a type</li>
<li>Automatically generates &quot;getter&quot; style functions</li>
</ul>
<pre><code>    module RecordSyntax where

    data Game = GameC {
        homeTeam :: String
      , homeScore :: Int
      , awayTeam :: String
      , awayScore :: Int
    }

    result :: Game -&gt; String 
    result game
      | homeScore game &gt; awayScore game = (homeTeam game) ++ &quot; wins&quot;
      | awayScore game &gt; homeScore game = (awayTeam game) ++ &quot; wins&quot;
      | otherwise                       = &quot;Draw&quot;               
</code></pre>
</div>
<div id="sum-types" class="slide section level1">
<h1>Sum Types</h1>
<ul>
<li>A sum type can be one of many possibilities</li>
</ul>
<pre><code>    module SumTypes where

    data Result = Win | Lose | Draw deriving (Show)

    homeTeamResult :: Game -&gt; Result
    homeTeamResult game
      | homeScore game &gt; awayScore game = Win
      | awayScore game &gt; homeScore game = Lose
      | otherwise                       = Draw
    
    flipResult :: Result -&gt; Result
    flipResult Win  = Lose
    flipResult Lose = Win
    flipResult Draw = Draw</code></pre>
</div>
<div id="lets-define-our-own-data-types" class="slide section level1">
<h1>Let's define our own data types</h1>
<ul>
<li>Our domain is football matches.</li>
<li>Spend some time defining types such as: -- A basic result (Win, Lose or Draw) -- Team statistics (Team name, goals for, current points etc.)</li>
</ul>
<!--
  Let's say 15 minutes for defining a few types
-->

</div>
<div id="lists-in-a-bit-more-detail" class="slide section level1">
<h1>Lists in a bit more detail</h1>
<ul>
<li>All items in a list have to be the same type (no <code>[1,&quot;a&quot;]</code>)</li>
<li>Lists have special syntax in Haskell</li>
<li><code>[]</code> is the empty list</li>
<li><code>:</code> is the type constructor used to create lists <code>1 : [] =&gt; [1]</code></li>
<li><code>[1,2,3]</code> is syntactic sugar for <code>1 : (2 : (3 : []) )</code></li>
</ul>
</div>
<div id="lets-write-some-list-functions" class="slide section level1">
<h1>Let's write some list functions</h1>
<ul>
<li>Need to think recursively!</li>
<li>What's the base case?</li>
<li>What's the recursive case?</li>
</ul>
</div>
<div id="list-examples-1---length" class="slide section level1">
<h1>List Examples (1) - Length</h1>
<pre><code>
   myLength :: [a] -&gt; Int

   -- base case, an empty list is of length 0
   myLength [] = 0

   -- recursive case works towards the base case
   myLength (_:xs) = 1 + length xs</code></pre>
</div>
<div id="list-examples-2---building-new-lists" class="slide section level1">
<h1>List Examples (2) - Building new lists</h1>
<pre><code>   addOne :: [Int] -&gt; [Int]
   addOne [] = []
   addOne (x:xs) = (x + 1) : (addOne xs)</code></pre>
</div>
<div id="list-examples-3---including-only-some-elements" class="slide section level1">
<h1>List Examples (3) - Including only some elements</h1>
<pre><code>   greaterThan5 :: [Int] -&gt; [Int]
   greaterThan5 [] = []
   greaterThan5 (x:xs)
     | x &gt; 5     = x : greaterThan5 xs
     | otherwise = greaterThan5 xs</code></pre>
</div>
<div id="higher-order-functions" class="slide section level1">
<h1>Higher Order Functions</h1>
<ul>
<li>Functions are first class citizens</li>
<li>You can pass them to methods.</li>
</ul>
<pre><code>   map :: (a -&gt; b) -&gt; [a] -&gt; [b]
   map f []     = []
   map f (x:xs) = f x : map xs 

   -- more succinct definition
   -- point free (no args), partial application (+ 1)
   addOne = map (+ 1)</code></pre>
</div>
<div id="writing-list-functions" class="slide section level1">
<h1>Writing List functions</h1>
<ul>
<li>Can you write the following functions?
<ul>
<li><code>myContains :: Eq a =&gt; a -&gt; [a] -&gt; Bool</code></li>
<li><code>myFilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></li>
<li><code>myAppend :: [a] -&gt; [a] -&gt; [a]</code></li>
<li><code>myReduce :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</code></li>
<li><code>myReverse :: [a] -&gt; [a]</code></li>
</ul></li>
</ul>
<!-- This'll take a bit of a while, say 30 minutes -->

</div>
<div id="building-a-combinator-library" class="slide section level1">
<h1>Building a combinator library</h1>
<ul>
<li>Load up <code>HistoricalStats.hs</code></li>
<li>Write some simple functions to give information such as:
<ul>
<li>homeWin :: Game -&gt; Bool</li>
<li>awayWin :: Game -&gt; Bool</li>
<li>scoreDraw :: Game -&gt; Bool</li>
<li>totalGoals :: Game -&gt; Int</li>
</ul></li>
</ul>
<!-- this shouldn't take long -->

</div>
<div id="curried-functions" class="slide section level1">
<h1>Curried Functions</h1>
<ul>
<li>In Haskell all functions are of a single argument</li>
<li><code>add 3 4</code> is interpreted as ((add 3) 4)</li>
<li><code>add 3</code> returns a function needing one more argument</li>
<li>This is known as partial application</li>
</ul>
</div>
<div id="making-the-most-of-higher-order-functions" class="slide section level1">
<h1>Making the most of higher order functions</h1>
<ul>
<li>Function composition f . g =&gt; f g (x)</li>
</ul>
<pre><code>
    sort :: Ord a =&gt; [a] -&gt; [a]
    reverse :: [a] -&gt; [a]

    -- writing a definition
    reverseSort xs = reverse (sort xs)

    -- using function composition
    reverseSort = reverse . sort
</code></pre>
</div>
<div id="returning-functions-with-partial-application" class="slide section level1">
<h1>Returning functions with partial application</h1>
<ul>
<li>By combining functions together you can succinctly combine functions</li>
</ul>
<pre><code>  excitingGame :: Match -&gt; Bool
  excitingGame = totalGoals match &gt; 10

  -- Find all exciting games
  excitingGames :: [Match] -&gt; [Match]
  excitingGames = filter excitingGame</code></pre>
</div>
<div id="putting-it-all-together" class="slide section level1">
<h1>Putting it all together</h1>
<ul>
<li>We're going to work with Premier League Data for this season</li>
<li>We're going to write some code to allow us to quiz the data</li>
<li>From the REPL, I want to be able to ask questions like:
<ul>
<li>What game had the most goals?</li>
<li>What was the total number of goals scored?</li>
<li>Which team got most corners?</li>
<li>Which team was most entertaining?</li>
<li>If all games finished at half-time, who'd have won the league?</li>
</ul></li>
</ul>
</div>
<div id="what-next" class="slide section level1">
<h1>What next?</h1>
<ul>
<li>Real World Haskell is an excellent book</li>
<li>Use &quot;Hoogle&quot; to search for functionality based on type signatures</li>
<li>fpcomplete.com provides some great introductions</li>
</ul>
</div>
</body>
</html>
