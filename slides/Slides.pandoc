% Haskell Workshop
% Jeff Foster
% ACCU 2014

# About me!
- I'm Head of Software Engineering at Red Gate
- I'm most definitely NOT a Haskell expert
- Love learning new languages, tools and techniques

# Why Haskell?
- Purely functional, statically typed, lazy
- Different is good!

> A language that doesn't affect the way you think about programming is not worth knowing. (Alan Perlis)

# What do you need today?
- A text editor
- A version of the Haskell Platform <http://www.haskell.org/platform/>
- A git clone of <https://github.com/fffej/haskell-workshop>

# What are you going to do today?
>- You'll the basics of Haskell
>- You'll learn to read Haskell
>- You'll write a combinator library for analysing Premier League football matches

# Why Statically Typed?
>- Given the type signature below, what happens?

. . .

~~~~
   int add(int x,int y);
~~~~

>- Add two integers?  Maybe...  Or maybe

. . .

~~~~
   int add(int x,int y) { launchNukes(); return x+y; };
~~~~

# Haskell types
>- Given the type signature below, what happens?

. . . 

~~~~
   add :: Int -> Int -> Int
~~~~

>- What can happen?

# Let's check everything is working.

- Put the following in `Main.hs`

~~~~
   module HelloWorld where
   main = putStrLn "Hello, World!"
~~~~

- Each Haskell function is within a module
- `main` is the entry point
- Load this into ghci with `:l Main.hs` and run with `main`

<!-- 
     Quick stop to let everyone find out that Haskell works for them 
     5 minutes?  Hopefully enough people have working machines
-->

# GHCI
- GHCI is the de-facto Haskell interpreter
- Provides a REPL and a way to explore the code
- Expressions entered are evaluated and returned
- For this workshop, work in a file and use `:l <file>` to reload

# Let's write some simple functions and explore some syntax

~~~~

  module Add where

  -- function definition
  add x y = x + y

  -- Pattern matching
  add2 0 y = y
  add2 x 0 = x
  add2 x y = 1 + add2 (x - 1) y

  -- Guards 
  add3 x y 
    | x == 0    = y -- read | as "where"
    | y == 0    = x
    | otherwise = 1 + add3 (x - 1) y

~~~~

# Types 

- We haven't written type signatures yet
- Haskell has inferred types for us
- In ghci, `:t <expression>` tells us the type
- `:t add` says `add :: Num a => a -> a -> a`

# Types are everything

- Often a type signature says *everything* about a function.
- Types are denoted with an initial Capital letter
- Type parameters (generics) are written with a lower case parameter
- What do these functions do? (hint, remember they must work for all types)
- `fooHicky :: (a,b) -> a`
- `banana   :: a -> a`

# Types or type variables?

- What does the type `Int -> Int -> Int` tell you?
- What does the type `a -> a -> a` tell you?
- The more general the type signature, the *more* it tells you!

# Type Classes
- Think of a type class as an interface
- Common type classes are `Eq` and `Show` which define equality and printability
- Use `:i <TypeClass>` to inspect a type class in ghci e.g.

~~~~
  > :i Eq
  class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    --etc
~~~~

# Building your own types

- Data types are constructed and deconstructed via *type constructors*

~~~~
    module SimpleTypes where

    -- Game is the type
    -- GameC is the type constructor
    data Game = GameC String Int String Int

    -- Function type signatures use the type
    result :: Game -> String

    -- Function definitions "Deconstruct" values with the type constructor
    result (GameC t1 s1 t2 s2)
      | s1 > s2   = t1 ++ " wins"
      | s2 > s1   = t2 ++ " wins"
      | otherwise = "Draw"
~~~~

# Record Syntax

- Provides a way of naming parts of a type
- Automatically generates "getter" style functions

~~~~
    module RecordSyntax where

    data Game = GameC {
    	homeTeam :: String
      , homeScore :: Int
      , awayTeam :: String
      , awayScore :: Int
    }

    result :: Game -> String 
    result game
      | homeScore game > awayScore game = (homeTeam game) ++ " wins"
      | awayScore game > homeScore game = (awayTeam game) ++ " wins"
      | otherwise                       = "Draw"          	   

~~~~

# Sum Types
- A sum type can be one of many possibilities

~~~~
    module SumTypes where

    data Result = Win | Lose | Draw deriving (Show)

    homeTeamResult :: Game -> Result
    homeTeamResult game
      | homeScore game > awayScore game = Win
      | awayScore game > homeScore game = Lose
      | otherwise                       = Draw
    
    flipResult :: Result -> Result
    flipResult Win  = Lose
    flipResult Lose = Win
    flipResult Draw = Draw
~~~~

# Let's define our own data types and functions

- Our domain is football matches.
- `data/FootballStats.hs` contains some example types.
- What simple functions can you write?

~~~~
    data FootballResult = FootballResult 
      {
        homeTeam :: String
      , awayTeam :: String
      , homeGoals :: Int
      , awayGoals :: Int
      -- and so on!
     } deriving (Show,Eq)

   totalGoals :: FootballResult -> Int
   homeScore :: FootballResult -> Int
   netGoals :: FootballResult -> Int
   violenceLevel :: FootballResult -> Int
~~~~

<!--
  Let's say 15 minutes for defining a few types

  And now since we've written some simple functions, we should
  focus on how to combine them across many items
-->

# Working with more than one type
- We now know how to create our own types
- Next is learning to work with lists of types

# Haskell Lists
- All items in a list have to be the same type (no `[1,"a"]`)
- Lists have special syntax in Haskell
- `[]` is the empty list
- `:` is the type constructor used to create lists `1 : [] => [1]`
- `[1,2,3]` is syntactic sugar for `1 : (2 : (3 : []) )`

<!--
  Should mention that `:` is a magic infix operator
--> 

# Thinking Recursively
- Recursive thinking consists of two steps:
>- What's the base case?
>- What's the recursive case that brings us nearer the base case

# List Examples (1) - Length

~~~~
   myLength :: [a] -> Int

   -- base case, an empty list is of length 0
   myLength [] = 0

   -- recursive case works towards the base case
   myLength (_:xs) = 1 + length xs
~~~~

# List Examples (2) - Building new lists

- Lists are immutable; build new ones with shared elements

~~~~
   addOne :: [Int] -> [Int]
   addOne [] = []
   addOne (x:xs) = (x + 1) : (addOne xs)
~~~~

# List Examples (3) - Including only some elements

- Build a new list with only the elements we want

~~~~
   greaterThan5 :: [Int] -> [Int]
   greaterThan5 [] = []
   greaterThan5 (x:xs)
     | x > 5     = x : greaterThan5 xs
     | otherwise = greaterThan5 xs
~~~~

# Higher Order Functions

- Functions are first class citizens

~~~~
   mymap :: (a -> b) -> [a] -> [b]
   mymap f []     = []
   mymap f (x:xs) = f x : map f xs 

   -- more succinct definition
   -- point free (no args), partial application (+ 1)
   addOne' = map (+ 1)
~~~~

# Writing List functions
- Can you write the following functions?
    - `myContains :: Eq a => a -> [a] -> Bool`
    - `myFilter :: (a -> Bool) -> [a] -> [a]`
    - `myReduce :: (a -> b -> a) -> a -> [b] -> a`
    - `myReverse :: [a] -> [a]` 

<!-- 
     This'll take a bit of a while, say 30 minutes 

     Maybe consider cutting out reduce? 
-->

# Building up some tools
- Load up `FootballStats.hs`
- `results2011` and `results2012` are of type `[FootballResult]`


# Using Type Signatures
- Given the following types, how can we find out the highest scoring game?

~~~~
   -- From Data.List
   maximumBy :: (a -> a -> Ordering) -> [a] -> a
   
   -- From Data.Ord
   comparing :: Ord a => (b -> a) -> b -> b -> Ordering
~~~~

# Walk through
- I'm going to attempt this live, brace yourself

# Over to you
- Who won the league?
- If scores were counted at half-time, who would win the league?
- If yellow and red cards were counted as goals, who'd win?

# Combining Functions Effortlessly
- In Haskell all functions are of a single argument
- `add 3 4` is interpreted as ((add 3) 4)
- `add 3` returns a function needing one more argument
- This is known as partial application

# Making the most of higher order functions

- Function composition f . g => f g (x)
    
~~~~
    sort :: Ord a => [a] -> [a]
    reverse :: [a] -> [a]

    -- writing a definition
    reverseSort xs = reverse (sort xs)

    -- using function composition
    reverseSort = reverse . sort
~~~~ 

# Returning functions with partial application

- By combining functions together you can succinctly combine functions

~~~~
  excitingGame :: Match -> Bool
  excitingGame = totalGoals match > 10

  -- Find all exciting games
  excitingGames :: [FootballResult] -> [FootballResult]
  excitingGames = filter excitingGame
~~~~

<!-- TODO; this section is weak! --> 
# Putting it all together
- We're going to work with Premier League Data for this season
- We're going to write some code to allow us to quiz the data
- From the REPL, I want to be able to ask questions like:
    - What game had the most goals?
    - What was the total number of goals scored?
    - Which team got most corners?
    - Which team was most entertaining?
    - If all games finished at half-time, who'd have won the league?

# What next?
- Real World Haskell is an excellent book
- Use "Hoogle" to search for functionality based on type signatures
- fpcomplete.com provides some great introductions

