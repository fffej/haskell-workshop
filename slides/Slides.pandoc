% Haskell Workshop
% Jeff Foster
% ACCU 2014

# About me!
- I'm Head of Software Engineering at Red Gate
- I'm most definitely NOT a Haskell expert
- Love learning new languages, tools and techniques

# Why Haskell?
- Purely functional, statically typed, lazy
- Different is good!

> A language that doesn't affect the way you think about programming is not worth knowing. (Alan Perlis)

# What do you need today?
- A text editor
- A version of the Haskell Platform <http://www.haskell.org/platform/>

# What are you going to do today?
>- You'll the basics of Haskell
>- You'll learn to read Haskell
>- You'll write a combinator library for analysing Premier League football matches

. . .

>![](img/escalated_quickly.jpg "That escalated quickly")

# Why Statically Typed?
>- Given the type signature below, what happens?

. . .

~~~~
   int add(int x,int y);
~~~~

>- Add two integers?  Maybe...  Or maybe

. . .

~~~~
   int add(int x,int y) { launchNukes(); return 53; };
~~~~

# Haskell types
>- Given the type signature below, what happens?

~~~~
   add :: Int -> Int -> Int
~~~~

>- What can happen?

# Let's check everything is working.

~~~~
   module Main where
   main = putStrLn "Hello, World!"
~~~~

- Each Haskell function is within a module
- `main` is the entry point
- Load this into ghci with `:l Main.hs` and run with `main`

<!-- 
     Quick stop to let everyone find out that Haskell works for them 
     5 minutes?  Hopefully enough people have working machines
-->

# GHCI
- GHCI is the de-facto Haskell interpreter
- Provides a REPL and a way to explore the code
- Expressions entered are evaluated and returned
- For this workshop, work in a file and use `:l <file>` to reload

# Let's write some simple functions and explore some syntax

~~~~

  module Example where

  -- function definition
  add x y = x + y

  -- Pattern matching
  add2 0 y = y
  add2 x 0 = x
  add2 x y = 1 + add2 (x - 1) y

  -- Guards 
  add3 x y 
    | x == 0    = y -- read | as "where"
    | y == 0    = x
    | otherwise = 1 + add3 (x - 1) y

~~~~

# Curried Functions
- In Haskell all functions are of a single argument
- `add 3 4` is interpreted as ((add 3) 4)
- `add 3` returns a function needing one more argument
- This is known as partial application

# Types 

- We haven't written type signatures yet
- Haskell has inferred types for us
- In ghci, `:t <expression>` tells us the type
- `:t (+)` says `(+) :: Num a => a -> a -> a`
- What does this mean? 

# Types are everything

- Often a type signature says everything about a function.
- Types are denoted with an initial Capital letter
- Type parameters are written with a lower case parameter
- What do these functions do? (hint, remember they must work for all types)
- `fooHicky :: (a,b) -> a`
- `banana   :: a -> a`
    - In C#, these might look like this:
    - `public static A FooHickey<A,B>(A a, B b)`
    - `public static A banana<A>(A a)`

# Types or type variables?

- What does the type `Int -> Int -> Int` tell you?
- What does the type `a -> a -> a` tell you?
- The more general the type signature, the *more* it tells you!

# Type Classes
- Think of a type class as an interface
- Common type classes are `Eq` and `Show` which define equality and printability
- Use `:i <TypeClass>` to inspect a type class in ghci e.g.

~~~~
  > :i Num
  class Num a where
    (+) :: a -> a -> a
    (*) :: a -> a -> a
    --etc
~~~~

- You can automatically derive `Show` and `Eq` to get printable and equality support

# Defining new types

- Data types are constructed via *type constructors*
- Data types are pattern matched via *type constructors*

~~~~
    data Rectangle = RectangleConstructor Int Int

    area :: Rectangle -> Int
    area (RectangleConstructor a b) = a * b
~~~~

# Writing type signatures

- Start with the type of the functions
- Make the compiler check it makes sense
- Fill in the blanks
- Bottom up programming

<!-- TODO mention undefined -->


# Lists in a bit more detail
- All items in a list have to be the same type (no `[1,"a"]`)
- Lists have special syntax in Haskell
- `[]` is the empty list
- `:` is the type constructor used to create lists `1 : [] => [1]`
- `[1,2,3]` is syntactic sugar for `1 : (2 : (3 : []) )`

# Let's write some list functions
- Need to think recursively! 
- What's the base case?
- What's the recursive case?

# Length

~~~~
   -- base case, an empty list
   length [] = 0

   -- recursive case is a list of at least one element
   length (_:xs) = 1 + length xs
~~~~

# Adding one to each element

~~~~
   addOne :: [Int] -> [Int]
   addOne [] = []
   addOne (x:xs) = (x + 1) : (addOne xs)
~~~~

# Higher Order Functions

- Functions are first class citizens
- You can pass them to methods, partially apply them

~~~~
   map :: (a -> b) -> [a] -> [b]
   map f []     = []
   map f (x:xs) = f x : map xs 

   -- more succinct definition
   -- point free (no args), partial application (+ 1)
   addOne = map (+ 1)
~~~~

# Writing List functions
- Can you write the following functions?
    - `myContains :: Eq a => a -> [a] -> Bool`
    - `myFilter :: (a -> Bool) -> [a] -> [a]`
    - `myAppend :: [a] -> [a] -> [a]`
    - `myReduce :: (a -> b -> a) -> a -> [b] -> a`
    - `myReverse :: [a] -> [a]` 

# Sum Types

TODO - Be harsh; do I absolutely need to include this for football matches?

- A sum type can be one of many possibilities

~~~~
  data Shape = Square Double
             | Circle Double 
             | Rectangle Double Double
             deriving (Show, Eq)
~~~~

>- How would you write a function `area :: Shape -> Double`?
>- Remember, use the type constructor to take things apart!
>- Shape is the *type*, Square, Circle and Rectangle are type constructors

# Record syntax

- Allows you to generate names for parts of a type

~~~~

   data Person = PersonC
      {
        firstName :: String,
        lastName  :: String
      }

   -- Automatically generates accessor methods
   -- lastName :: Person -> String
   -- firstName :: Person -> String
   aPerson = PersonC { firstName = "Joe", lastName = "Bloggs" }

   > lastName aPerson
   => "Bloggs" 
~~~~

# Enough Talking (sorry)
- Write some data types for a Premier League football match
    - e.g. Everton 1 - Man United 0 (first team is the home team)

- Write some simple functions to give information such as: 
    - homeWin :: Game -> Bool
    - awayWin :: Game -> Bool
    - scoreDraw :: Game -> Bool
    - totalGoals :: Game -> Int

# Making the most of higher order functions

- Function composition f . g => f g (x)
    
~~~~

    sort :: Ord a => [a] -> [a]
    reverse :: [a] -> [a]

    -- writing a definition
    reverseSort xs = reverse (sort xs)

    -- using function composition
    reverseSort = reverse . sort

~~~~ 

# Returning functions with partial application

- By combining functions together you can succinctly

~~~~
  moreThanNGoals :: Int -> Match -> Bool
  moreThanNGoals n match = totalGoals match > n

  excitingGame :: Match -> Bool
  excitingGame = moreThanNGoals 10

  -- Find all exciting games
  excitingGames :: [Match] -> [Match]
  excitingGames = filter excitingGame
~~~~

# Putting it all together
- We're going to work with Premier League Data for this season
- We're going to write some code to allow us to quiz the data
- From the REPL, I want to be able to ask questions like:
    - What game had the most goals?
    - What was the total number of goals scored?
    - Which team got most corners?
    - Which team was most entertaining?
    - If all games finished at half-time, who'd have won the league?

# What next?
- Real World Haskell is an excellent book
- Use "Hoogle" to search for functionality based on type signatures
- fpcomplete.com provides some great introductions

<!-- Supplemental material, (definitely) won't get here? -->

# Property Based Testing
- The type system can encode lots of properties about your data
- Property based tested can help you assert more about your data
- Instead of existential tests (`assert 1 + 1 == 2`) write universal tests (`a + b == b + a`)

# Asserting Invariants

~~~~
  reverse :: [a] -> [a]
  
  prop_LenPreserving :: [a] -> Bool
  prop_LenPreserving xs = length xs == length (reverse xs)

  > quickCheck prop_LenPreserving
  +++ OK, passed 100 tests

~~~~ 

# Finding errors

~~~~
  badSort :: Ord a => [a] -> [a]
  badSort [] = []
  badSort xs = minimum xs : tail xs

  > badSort [1,2,3,4] 
  [1,2,3,4]

  model_test :: [Int] -> Bool
  model_test xs = sort xs == badSort xs

  > quickCheck model_test
  *** Failed! Falsifiable (after 4 tests):
  [0, -1]
~~~~